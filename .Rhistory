KM_frame0 <- data.frame(
"time" = res_sum0$time,
"sp0" = res_sum0$surv,
"sp1" = 0
)[res_sum0$n.event != 0, ]
KM_frame1 <- data.frame(
"time" = IRange,
"sp0" = sp_matrix2sp,
"sp1" = 0
)
for (i in 1:nrow(KM_frame0)) {
t <- KM_frame0$time[i]
if (t < min(KM_frame1$time)) {
KM_frame0$sp1[i] <- 1
} else {
index <- max(which(KM_frame1$time <= t))
KM_frame0$sp1[i] <- KM_frame1$sp0[index]
}
}
KM_frame0$t_IAE <- abs(KM_frame0$sp0 - KM_frame0$sp1)
KM_frame0$t_ISE <- (KM_frame0$sp0 - KM_frame0$sp1)^2
IAE <- 0
ISE <- 0
for (i in 1:(nrow(KM_frame0) - 1)) {
IAE <- IAE + (KM_frame0$time[i + 1] - KM_frame0$time[i]) * KM_frame0$t_IAE[i]
ISE <- ISE + (KM_frame0$time[i + 1] - KM_frame0$time[i]) * KM_frame0$t_ISE[i]
}
IAEISE_value <- c(IAE, ISE)
names(IAEISE_value) <- c("IAE", "ISE")
return(IAEISE_value)
}
library(survival)
library(randomForestSRC)
library(pec)
set.seed(1234)
mydata <- kidney[, -1]
train_index <- sample(1:nrow(mydata), 0.8 * nrow(mydata))
train_data <- mydata[train_index, ]
test_data <- mydata[-train_index, ]
coxfit <- coxph(Surv(time, status) ~ ., data = train_data, x = TRUE)
distime <- sort(unique(as.vector(coxfit$y[coxfit$y[, 2] == 1])))
sp_matrix <- predictSurvProb(coxfit, test_data, distime)
time <- test_data$time
status <- test_data$status
IAEISE(Surv(time, status), sp_matrix)
IAEISE(Surv(time[-1], status), sp_matrix)
IAEISE(Surv(time, status), sp_matrix, c(2, 1))
#' IAEISE
#'
#' Two ways of the continuous-time approach to continuous-time identification based on least-squares and least-absolute errors are proposed.
#' Integrate Absolute Error and Integrate Square Error.To evaluate the performance of survival models methods
#' Lower values of IAE or ISE indicate better performances.
#'
#' @aliases IAEISE
#' @param object object of class \code{Surv} on the testing set created by Surv function.
#' @param sp_matrix a matrix of predicted values of survival probabilities for the testing set.
#' @param IRange a vector contains all discrete time points corresponding to the predicted probability in sp_matrix.
#' Or the scale you want to get the IAE and ISE;  .
#'
#' @return Estimates of the IAE and ISE
#' @author Hanpu Zhou \email{zhouhanpu@csu.edu.cn}
#' @references
#' Marron, J. S. , &  Wand, M. P. . (1992). Exact mean integrated squared error. Annals of Statistics, 20(2), 712-736.
#'
#' HooraMoradian, DenisLarocque, & FranoisBellavance. (2017). L1 splitting rules in survival forests. Lifetime Data Analysis, 23(4), 671–691.
#'
#' Kowalczuk, & Z. (1998). Integrated squared error and integrated absolute error in recursive identification of continuous-time plants. Control 98 Ukacc International Conference on (Vol.1998, pp.693-698). IET.
#'
#' @examples
#'
#' library(survival)
#' library(SurvMetrics)
#' set.seed(123)
#' N <- 100
#' mydata <- SDGM4(N, p = 20, c_step = -0.5)
#' index.train <- sample(1:N, 2 / 3 * N)
#' data.train <- mydata[index.train, ]
#' data.test <- mydata[-index.train, ]
#'
#' time_interest <- sort(data.train$time[data.train$status == 1])
#' sp_matrix <- matrix(sort(runif(nrow(data.test) * length(time_interest)),
#'   decreasing = TRUE
#' ), nrow = nrow(data.test))
#' object <- Surv(data.test$time, data.test$status)
#'
#' # a vector for all the distinct time
#' IAEISE(object, sp_matrix, time_interest)
#' # a range
#' IAEISE(object, sp_matrix, c(12, 350))
#'
#' @importFrom survival Surv
#' @importFrom survival survfit
#'
#' @export
IAEISE <- function(object, sp_matrix, IRange = c(-2, -1)) {
# case1、coxph AND testing set
if (inherits(object, "coxph")) {
obj <- object
test_data <- sp_matrix
# the interesting times of training set
distime <- sort(unique(as.vector(obj$y[obj$y[, 2] == 1])))
mat_coxph <-
predictSurvProb(obj, test_data, distime) # get the survival probability matrix
object_coxph <- Surv(test_data$time, test_data$status)
object <- object_coxph
sp_matrix <- mat_coxph
if (max(IRange) <= 0) {
IRange <- range(object[, 1])
} # the fixed time point
}
# case2、RSF AND testing set
if (inherits(object, c("rfsrc"))) {
obj <- object
test_data <- sp_matrix
mat_rsf <-
predict(obj, test_data)$survival # get the survival probability matrix
object_rsf <- Surv(test_data$time, test_data$status)
object <- object_rsf
sp_matrix <- mat_rsf
if (max(IRange) <= 0) {
IRange <- range(object[, 1])
} # the fixed time point
}
# case3 survreg AND testing set
if (inherits(object, c("survreg"))) {
obj <- object
test_data <- sp_matrix
# the interesting times of training set
distime <- sort(unique(as.vector(obj$y[obj$y[, 2] == 1])))
object <- Surv(test_data$time, test_data$status)
sp_matrix <- predictSurvProb.survreg(obj, test_data, distime)
if (max(IRange) <= 0) {
IRange <- range(object[, 1])
} # the fixed time point
}
if (any(is.na(IRange))) {
stop("Cannot calculate IAE or ISE in the interval containing NA")
}
if (!is.numeric(IRange)) {
stop("The class of the IRange must be numeric! or use the default setting")
}
#default time range for IAEISE()
if(max(IRange) <= 0 ){
IRange <-  range(object[, 1])
}
if (!inherits(object, "Surv")) {
stop("object is not of class Surv")
}
if (missing(object)) {
stop("The survival object of the testing set is missing")
}
if (missing(sp_matrix)) {
stop("The prediction of the survival probability matrix is missing")
}
if (any(is.na(object))) {
stop("The input vector cannot have NA")
}
if (any(is.na(sp_matrix))) {
stop("The input probability matrix cannot have NA")
}
if (length(IRange) <= 1) {
stop("Can not calculate the integration at a single point")
}
if (any(IRange <= 0)) {
stop("The interval must be positive")
}
if (any(diff(IRange) <= 0)) {
stop("The interval value must increase")
}
# Simulation to generate discrete time series
sp_matrix2sp <- apply(sp_matrix, 2, mean)
if (length(IRange) != ncol(sp_matrix)) {
t_IRange <- range(IRange)
p <- ncol(sp_matrix)
IRange <- seq(t_IRange[1], t_IRange[2], length = p)
}
fit0 <- survfit(object ~ 1)
res_sum0 <- survminer::surv_summary(fit0)
KM_frame0 <- data.frame(
"time" = res_sum0$time,
"sp0" = res_sum0$surv,
"sp1" = 0
)[res_sum0$n.event != 0, ]
KM_frame1 <- data.frame(
"time" = IRange,
"sp0" = sp_matrix2sp,
"sp1" = 0
)
for (i in 1:nrow(KM_frame0)) {
t <- KM_frame0$time[i]
if (t < min(KM_frame1$time)) {
KM_frame0$sp1[i] <- 1
} else {
index <- max(which(KM_frame1$time <= t))
KM_frame0$sp1[i] <- KM_frame1$sp0[index]
}
}
KM_frame0$t_IAE <- abs(KM_frame0$sp0 - KM_frame0$sp1)
KM_frame0$t_ISE <- (KM_frame0$sp0 - KM_frame0$sp1)^2
IAE <- 0
ISE <- 0
for (i in 1:(nrow(KM_frame0) - 1)) {
IAE <- IAE + (KM_frame0$time[i + 1] - KM_frame0$time[i]) * KM_frame0$t_IAE[i]
ISE <- ISE + (KM_frame0$time[i + 1] - KM_frame0$time[i]) * KM_frame0$t_ISE[i]
}
IAEISE_value <- c(IAE, ISE)
names(IAEISE_value) <- c("IAE", "ISE")
return(IAEISE_value)
}
IAEISE(Surv(time, status), sp_matrix, c(2, 1))
Surv(c(-1, 1), c(1, 1))
library(survival)
Surv(c(-1, 1), c(1, 1))
devtools::test()
library(survival)
library(randomForestSRC)
library(pec)
set.seed(1234)
mydata <- kidney[, -1]
View(mydata)
table(mydata$status)
18/(18+58)
devtools::test()
library(SurvMetrics)
library(survival)
Cindex(Surv(c(1,2),c(1,1)),c(0.5,0.6))
install.packages("Matrix")
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.6-0.tar.gz")
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.5-1.tar.gz")
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.5-1.tar.gz")
install.packages("Matrix")
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.6-1.tar.gz")
Matrix R::dependencies()
Matrix R::dependencies()
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.6-5.tar.gz")
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.6-4.tar.gz")
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.6-3.tar.gz")
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.6-2.tar.gz")
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.5-1.tar.gz")
sessionInfo()
install.packages("https://cran.r-project.org/src/contrib/Archive/Matrix/Matrix_1.4-1.tar.gz")
library(survival)
time <- c(1, 1, 2, 2, 2, 2, 2, 2)
status <- c(0, 1, 1, 0, 1, 1, 0, 1)
pre_sp <- c(0.3, 0.2, 0.4, 0.5, 0.9, 0.1, 0.2, 0.7)
expect_type(Brier(Surv(time, status), pre_sp), "double")
install.packages("testhat")
install.packages("testthat")
library(testthat)
library(survival)
time <- c(1, 1, 2, 2, 2, 2, 2, 2)
status <- c(0, 1, 1, 0, 1, 1, 0, 1)
pre_sp <- c(0.3, 0.2, 0.4, 0.5, 0.9, 0.1, 0.2, 0.7)
expect_type(Brier(Surv(time, status), pre_sp), "double")
expect_output(Brier(Surv(time, status), pre_sp), 0.468571)
library(SurvMetrics)
expect_type(Brier(Surv(time, status), pre_sp), "double")
expect_output(Brier(Surv(time, status), pre_sp), 0.468571)
Brier(Surv(time, status), pre_sp)
expect_output(Brier(Surv(time, status), pre_sp), 0.468571)
Brier(Surv(time, status), pre_sp)
expect_output
expect_output(Brier(Surv(time, status), pre_sp), 0.468571)
expect_type(Brier(Surv(time, status), pre_sp), "double")
Brier(Surv(time, status), pre_sp)
class(Brier(Surv(time, status), pre_sp), "double"))
class(Brier(Surv(time, status), pre_sp), "double"))
class(Brier(Surv(time, status), pre_sp), "double"))
Brier(Surv(time, status), pre_sp), "double")
Brier(Surv(time, status), pre_sp), "double")
Brier(Surv(time, status), pre_sp)
expect_output(Brier(Surv(time, status), pre_sp), 0.468571)
expect_type(Brier(Surv(time, status), pre_sp), "double")
testthat_example()
str(mtcars)
#>  $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...
#>  $ disp: num  160 160 108 258 360 ...
#>  $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...
#>  $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...
#>  $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...
#>  $ qsec: num  16.5 17 18.6 19.4 17 ...
#>  $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...
#>  $ am  : num  1 1 1 0 0 0 0 0 0 0 ...
#>  $ gear: num  4 4 4 3 3 3 3 4 4 4 ...
#>  $ carb: num  4 4 1 1 2 1 4 2 2 4 ...
expect_output(str(mtcars), "32 obs")
expect_output(str(mtcars), "11 variables")
str(mtcars)
(Brier(Surv(time, status), pre_sp)
)
expect_output(Brier(Surv(time, status), pre_sp), 0.468571)
expect_output(Brier(Surv(time, status), pre_sp))
expect_output(Brier(Surv(time, status), pre_sp),"Brier")
expect_output(Brier(Surv(time, status), pre_sp)," ")
expect_output(Brier(Surv(time, status), pre_sp))
expect_output(str(mtcars), "$ mpg", fixed = TRUE)
expect_output(Brier(Surv(time, status), pre_sp), "0.468571")
Brier(Surv(time, status), pre_sp)
dd=Brier(Surv(time, status), pre_sp)
typeof(dd)
class(dd)
dd
names(dd)
dd[1]
dd[2]
dd[0]
dd[1]
expect_equal(Brier(Surv(time, status), pre_sp), "0.468571")
expect_equal(Brier(Surv(time, status), pre_sp), 0.468571)
expect_type(Brier(Surv(time, status), pre_sp), "double")
expval=0.468571
names(expval)="Brier Score"
expect_equal(Brier(Surv(time, status), pre_sp), expval)
expect_output(Brier(Surv(time, status), pre_sp), expval)
expval=0.468571
names(expval)="Brier Score"
expect_output(Brier(Surv(time, status), pre_sp), expval)
Brier(coxfit, test_data)
# case2 fit object
library(randomForestSRC)
library(pec)
set.seed(1234)
mydata <- kidney[, -1]
train_index <- sample(1:nrow(mydata), 0.7 * nrow(mydata))
train_data <- mydata[train_index, ]
test_data <- mydata[-train_index, ]
# test coxph
coxfit <- coxph(Surv(time, status) ~ ., data = train_data, x = TRUE)
expect_type(Brier(coxfit, test_data), "double")
expval2=0.183243
names(expval2)="Brier Score"
expect_equal(Brier(coxfit, test_data), expval2)
# test RSF
rsffit <- rfsrc(Surv(time, status) ~ ., data = train_data)
expect_type(Brier(rsffit, test_data), "double")
expval3=0.215768
names(expval3)="Brier Score"
expect_equal(Brier(rsffit, test_data), expval3)
Brier(rsffit, test_data)
library(survival)
time <- c(1, 1, 2, 2, 2, 2, 2, 2)
status <- c(0, 1, 1, 0, 1, 1, 0, 1)
predicted <- c(2, 3, 3, 3, 4, 2, 4, 3)
expect_type(Cindex(Surv(time, status), predicted), "double")
expect_output(Cindex(Surv(time, status), predicted), 0.6428571)
Cindex(Surv(time, status), predicted)
expval=0.6428571
names(expval)="C index"
expect_equal(Cindex(Surv(time, status), predicted), expval)
expval=0.642857
names(expval)="C index"
expect_equal(Cindex(Surv(time, status), predicted), expval)
expect_output(Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.6)), 1)
expval=1
expect_equal(Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.6)), expval)
Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.6))
S
expect_equal(Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.6)), expval)
names(expval)="C index"
expect_equal(Cindex(Surv(time, status), predicted), expval)
expval=1
library(survival)
time <- c(1, 1, 2, 2, 2, 2, 2, 2)
status <- c(0, 1, 1, 0, 1, 1, 0, 1)
predicted <- c(2, 3, 3, 3, 4, 2, 4, 3)
expect_type(Cindex(Surv(time, status), predicted), "double")
expval=0.642857
names(expval)="C index"
expect_equal(Cindex(Surv(time, status), predicted), expval)
expval=1
expect_equal(Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.6)), expval)
expval
expect_equal(Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.6)), 1)
expval=1; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.6)), 1)
expect_equal(Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.6)), expval1)
expval=1; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.6)), expval)
expval=0; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,2), c(1,1)), c(0.6, 0.5)), expval)
expval=0; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,2), c(1,1)), c(0.6, 0.5)), expval)
expval=0.5; names(expval)="C index"
expect_output(Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.5)), expval)
expval=1; names(expval)="C index"
expval=0.5; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,2), c(1,1)), c(0.5, 0.5)), expval)
expval=1; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,1), c(1,1)), c(0.5, 0.5)), expval)
expval=0.5; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,1), c(1,1)), c(0.5, 0.6)), expval)
expect_equal(Cindex(Surv(c(1,1), c(1,0)), c(0.5, 0.5)), 0.5)
expval=0.5; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,1), c(1,0)), c(0.5, 0.5)), expval)
expval=0.5; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,1), c(1,0)), c(0.5, 0.6)), expval)
expval=1; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,1), c(1,0)), c(0.6, 0.5)),expval)
expval=0.5; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,1), c(1,0)), c(0.5, 0.5)), expval)
expval=0.5; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,1), c(1,0)), c(0.5, 0.6)), expval)
expval=1; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,1), c(1,0)), c(0.6, 0.5)),expval)
expval=0.5; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,1), c(1,0)), c(0.6, 0.5)),expval)
expval=1; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,2), c(1,0)), c(0.5, 0.6)), expval)
expval=0.5; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,2), c(1,0)), c(0.5, 0.5)), expval)
expval=0; names(expval)="C index"
expect_equal(Cindex(Surv(c(1,2), c(1,0)), c(0.6, 0.5)), expval)
IAEISE(Surv(time, status), sp_matrix)
library(survival)
library(randomForestSRC)
library(pec)
set.seed(1234)
mydata <- kidney[, -1]
train_index <- sample(1:nrow(mydata), 0.7 * nrow(mydata))
train_data <- mydata[train_index, ]
test_data <- mydata[-train_index, ]
coxfit <- coxph(Surv(time, status) ~ ., data = train_data, x = TRUE)
distime <- sort(unique(as.vector(coxfit$y[coxfit$y[, 2] == 1])))
sp_matrix <- predictSurvProb(coxfit, test_data, distime)
time <- test_data$time
status <- test_data$status
expect_type(IAEISE(Surv(time, status), sp_matrix), "double")
expect_output(IAEISE(Surv(time, status), sp_matrix), c(132.0101, 44.3022))
IAEISE(Surv(time, status), sp_matrix)
expect_equal(IAEISE(Surv(time, status), sp_matrix), c(132.0101, 44.3022))
expect_type(IAEISE(Surv(time, status), sp_matrix), "double")
expval=c(132.0101, 44.3022)
names(expval)=('IAE', 'ISE')
expect_equal(IAEISE(Surv(time, status), sp_matrix), expval)
expect_type(IAEISE(Surv(time, status), sp_matrix), "double")
expval=c(132.0101, 44.3022)
names(expval)=('IAE', 'ISE')
names(expval)=c('IAE', 'ISE')
expect_equal(IAEISE(Surv(time, status), sp_matrix), expval)
# case 1 Surv object
library(survival)
library(randomForestSRC)
library(pec)
set.seed(1234)
mydata <- kidney[, -1]
train_index <- sample(1:nrow(mydata), 0.7 * nrow(mydata))
train_data <- mydata[train_index, ]
test_data <- mydata[-train_index, ]
coxfit <- coxph(Surv(time, status) ~ ., data = train_data, x = TRUE)
distime <- sort(unique(as.vector(coxfit$y[coxfit$y[, 2] == 1])))
sp_matrix <- predictSurvProb(coxfit, test_data, distime)
time <- test_data$time
status <- test_data$status
expect_type(IBS(Surv(time, status), sp_matrix), "double")
expval=0.177957
names(expval)="IBS"
expect_equal(IBS(Surv(time, status), sp_matrix), expval)
expect_error(
IBS(Surv(time[-1], status), sp_matrix),
"Time and status are different lengths"
)
expect_error(
IBS(Surv(time, status), sp_matrix, NA),
"The class of the IBSrange must be numeric! or use the default setting"
)
expect_error(
IBS(Surv(time, status), sp_matrix, c(1, NA)),
"Cannot calculate IBS in the interval containing NA"
)
expect_error(
IBS(Surv(time, status), sp_matrix, c(1, 1)),
"The integral interval value must increase"
)
expect_error(
IBS(Surv(time, status), sp_matrix, c(-1, 1)),
"The integration interval must be positive"
)
expect_error(
IBS(Surv(time, status), NA),
"The input probability matrix cannot have NA"
)
expect_error(
IBS(Surv(time, status), sp_matrix[-1, ]),
"number of rows of the sp_matrix and the survival object have different lengths"
)
time[1] <- NA
expect_error(
IBS(Surv(time, status), sp_matrix),
"The input vector cannot have NA"
)
# case2 fit object
# test coxph
coxfit <- coxph(Surv(time, status) ~ ., data = train_data, x = TRUE)
expect_type(IBS(coxfit, test_data), "double")
expect_type(IBS(coxfit, test_data), 0.177957)
IBS(coxfit, test_data)
library(Matrix)
library(SurvMetrics)
library(caret)
library(randomForestSRC)
library(survival)
library(pec)
library(ggplot2)
set.seed(123)
Sys.setenv("OMP_THREAD_LIMIT", "1")
Sys.setenv(OMP_THREAD_LIMIT, "1")
Sys.setenv("OMP_THREAD_LIMIT", "1")
Sys.setenv("OMP_THREAD_LIMIT" = 2)
Sys.setenv("OMP_THREAD_LIMIT" = 1)
renv::activate()
renv::status()
renv::snapshot()
